{"version":3,"file":"static/js/653.533ee749.chunk.js","mappings":"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","sources":["Loader/fetchAsyncIterator.ts","utils.ts","worker/DatasetCache.ts","colors/utils.ts","colors/palette.ts","worker/ColorProcessor.ts","worker/index.ts","../webpack/bootstrap","../webpack/runtime/amd options","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export default async function* gen<Item = unknown>(\n  reader: ReadableStreamDefaultReader,\n  { signal }: { signal?: AbortController['signal'] } = {},\n): AsyncGenerator<Item, void> {\n  const matcher = /\\r?\\n/;\n  const decoder = new TextDecoder();\n  let shouldAbort = false;\n\n  signal?.addEventListener('abort', () => {\n    shouldAbort = true;\n  });\n\n  let buf = '';\n\n  let next = reader.read();\n\n  while (true) {\n    if (shouldAbort) {\n      console.log('Aborting JSON line by line parsing');\n      break;\n    }\n\n    const { done, value } = await next;\n\n    if (done) {\n      if (buf.length > 0) {\n        yield JSON.parse(buf);\n      }\n\n      return;\n    }\n\n    const chunk = decoder.decode(value, { stream: true });\n    // debug(`chunk=${chunk}`);\n    buf += chunk;\n\n    const parts = buf.split(matcher);\n    buf = parts.pop() ?? '';\n    for (const i of parts) {\n      yield JSON.parse(i);\n    }\n\n    next = reader.read();\n  }\n}\n\nexport async function* fetchNDJSONBatch<T = unknown>(\n  url: string | Array<string>,\n  {\n    batchSize = 100,\n    limit,\n    onBatchDownloaded,\n    abortController,\n  }: {\n    batchSize?: number;\n    limit?: number;\n    onBatchDownloaded?: (total: number) => void;\n    abortController?: AbortController;\n  } = {},\n) {\n  const urls = Array.isArray(url) ? url : [url];\n  let totalBatches = 0;\n  let totalItems = 0;\n\n  let shouldAbort = false;\n\n  if (abortController) {\n    abortController.signal.addEventListener('abort', () => {\n      shouldAbort = true;\n    });\n  }\n\n  for (const url of urls) {\n    console.log(`Fetching data: ${url}`);\n    const res = await fetch(url, {\n      cache: 'force-cache',\n      signal: abortController?.signal,\n    });\n    const reader = res.body?.getReader();\n    if (!reader) {\n      throw new Error(`Unable to create reader`);\n    }\n\n    const iterator = gen<T>(reader);\n    console.log(`Created asyncIterator: url=${url}`);\n\n    let currentBatch: Array<T> = [];\n    for await (const res of iterator) {\n      if (shouldAbort) {\n        console.log(`Aborting dataset loading: url=${url}`);\n        throw new Error('Request aborted !');\n      }\n\n      if (onBatchDownloaded && totalItems % 100 === 0) {\n        onBatchDownloaded(totalItems);\n      }\n\n      currentBatch.push(res);\n      totalItems++;\n\n      if (totalItems === limit) {\n        console.log(`Limit of ${limit} items reached, returning`);\n        yield currentBatch;\n        iterator.return();\n        return;\n      }\n\n      if (currentBatch.length === batchSize) {\n        console.log(\n          `Yielded batch #${totalBatches++}, ${totalBatches * batchSize} total`,\n        );\n\n        yield currentBatch;\n        currentBatch = [];\n      }\n    }\n\n    console.log(\n      `Yielded final batch #${totalBatches}, ${\n        totalBatches * batchSize + currentBatch.length\n      } total`,\n    );\n\n    if (onBatchDownloaded) {\n      onBatchDownloaded(totalItems);\n    }\n    yield currentBatch;\n  }\n}\n","import { useTheme, useMediaQuery } from '@mui/material';\nimport { useDeviceSelectors } from 'react-device-detect';\n\n/**\n * Creates a typescript tuple from arguments\n * e.g: const a: [number, string] = tuple(1, 'abc');\n */\nexport function tuple<T extends any[]>(...args: T): T {\n  return args;\n}\n\nexport function useIsMobile(): { ua: boolean; mediaQuery: boolean } {\n  const [device] = useDeviceSelectors(window.navigator.userAgent);\n  const theme = useTheme();\n  const mediaQuery = useMediaQuery(theme.breakpoints.down('md'));\n\n  return { ua: device.isMobile, mediaQuery };\n}\n\nexport function ftToM(ft: number) {\n  return ft * 0.3048;\n}\n\nexport function mToFt(m: number) {\n  return m * 3.28084;\n}\n\nexport function flToM(fl: number) {\n  return ftToM(100 * fl);\n}\n","import type { DatasetMetadata, DatasetLoadOptions } from '../Loader/hooks';\nimport { fetchNDJSONBatch } from '../Loader/fetchAsyncIterator';\nimport type { TrajectoryItem } from '../scripts/parseTrajectory';\nimport type { DatasetLoadProgress } from './';\nimport { ftToM } from '../utils';\n\nexport type TrajectoryChunk = {\n  rawItems: Array<Omit<TrajectoryItem, 'timestampOffsets' | 'coordinates'>>;\n  positions: Float32Array;\n  timestampOffsets: Float32Array;\n  startIndices: Uint32Array;\n  squawks: Array<number | null>;\n};\n\nexport class DatasetCache {\n  private metadata: DatasetMetadata | null = null;\n  private loadOptions: DatasetLoadOptions | null = null;\n\n  public state: {\n    chunks: Array<TrajectoryChunk>;\n    loading: boolean;\n    error: null | Error;\n  } = { chunks: [], loading: false, error: null };\n\n  private setState(\n    updateFn: (prev: DatasetCache['state']) => DatasetCache['state'],\n  ) {\n    const nextState = updateFn(this.state);\n    this.state = nextState;\n  }\n\n  start = async ({\n    metadata,\n    loadOptions,\n    abortController,\n    onChunkLoaded,\n    onProgress,\n  }: {\n    metadata: DatasetMetadata;\n    loadOptions: DatasetLoadOptions;\n    abortController: AbortController;\n    onChunkLoaded: (\n      chunk: DatasetCache['state']['chunks'][number],\n      index: number,\n    ) => void;\n    onProgress: (statistics: DatasetLoadProgress) => void;\n  }): Promise<void> => {\n    const signal = abortController.signal;\n\n    this.setState((prev) => ({\n      ...prev,\n      loading: true,\n      error: null,\n      chunks: [],\n    }));\n\n    this.metadata = metadata;\n    this.loadOptions = loadOptions;\n\n    /**\n     * Reset statistics\n     */\n    const countByAo: { [key: string]: number } = {};\n    const statistics: DatasetLoadProgress = {\n      flights: 0,\n      downloadedFlights: 0,\n      drawnDataPoints: 0,\n      totalDataPoints: 0,\n      countByAo,\n    };\n\n    let asyncIterator = fetchNDJSONBatch<TrajectoryItem>(metadata.url, {\n      limit: loadOptions.hardLimit ?? undefined,\n      batchSize: loadOptions.batchSize,\n      abortController,\n      onBatchDownloaded: (total) => {\n        statistics.downloadedFlights = total;\n        onProgress(statistics);\n      },\n    });\n\n    const samplingRate = loadOptions.sampleRate;\n\n    /**\n     * Now we need to compute buffers for each batch.\n     *\n     */\n\n    let chunkIndex = 0;\n    for await (const trajectoryBatch of asyncIterator) {\n      if (signal.aborted) {\n        break;\n      }\n\n      let sampledIndices = 0;\n      let totalIndices = 0;\n      /**\n       * Count total number of trajectory items\n       */\n\n      const expectedPositions: Array<number> = [];\n      for (let i = 0; i < trajectoryBatch.length; i++) {\n        const t = trajectoryBatch[i];\n\n        // Compute aircraft operator statistics\n        if (t.aircraftOperator) {\n          if (!countByAo[t.aircraftOperator]) {\n            countByAo[t.aircraftOperator] = 0;\n          }\n\n          countByAo[t.aircraftOperator]++;\n        }\n\n        let expectedIndices = Math.floor(\n          t.timestampOffsets.length / samplingRate,\n        );\n\n        /**\n         * We need to add an extra slot in this case.\n         */\n        if (t.timestampOffsets.length % samplingRate !== 0) {\n          expectedIndices++;\n        }\n\n        sampledIndices += expectedIndices;\n        expectedPositions[i] = expectedIndices;\n\n        totalIndices += t.timestampOffsets.length;\n      }\n\n      const positions = new Float32Array(sampledIndices * 3);\n      const timestampOffsets = new Float32Array(sampledIndices);\n      const squawks = new Array(trajectoryBatch.length).fill(null);\n      const startIndices = new Uint32Array(trajectoryBatch.length);\n      startIndices[0] = 0;\n\n      for (let i = 0; i < trajectoryBatch.length; i++) {\n        const t = trajectoryBatch[i];\n        const numberOfItems = t.coordinates.length;\n\n        // Compute startIndices value\n        // We might set an out of bound value for the last iteration of the loop, but that's ok\n        let offset = startIndices[i];\n\n        for (let j = 0; j < numberOfItems; j++) {\n          if (j % samplingRate !== 0) {\n            continue;\n          }\n\n          const coordinates = t.coordinates[j];\n          const altitudeFt = coordinates[2];\n          const altitudeM = ftToM(altitudeFt);\n          positions[offset * 3] = coordinates[0];\n          positions[offset * 3 + 1] = coordinates[1];\n          positions[offset * 3 + 2] = altitudeM;\n          timestampOffsets[offset] = t.timestampOffsets[j];\n          squawks[offset] = t.squawks?.[j] ?? null;\n          offset++;\n        }\n\n        if (offset - startIndices[i] !== expectedPositions[i]) {\n          console.log(\n            `[WARNING] Flight ${t.callsign}, computed ${\n              offset - startIndices[i]\n            } positions, expected ${\n              expectedPositions[i]\n            }, initial number of positions = ${\n              t.coordinates.length\n            }, remainder = ${t.coordinates.length % samplingRate}`,\n          );\n        }\n\n        if (i + 1 !== trajectoryBatch.length) {\n          startIndices[i + 1] = offset;\n        }\n\n        /**\n         * Mutate the original object as this is a bit faster and less memory intensive\n         */\n        // @ts-ignore\n        delete t.coordinates;\n        // @ts-ignore\n        delete t.timestampOffsets;\n      }\n\n      if (trajectoryBatch.length > 0) {\n        console.log(\n          `Creating new trajectoryChunk, with ${startIndices.length} flights`,\n        );\n\n        if (signal.aborted) {\n          continue;\n        }\n\n        const chunk = {\n          rawItems: trajectoryBatch,\n          positions,\n          timestampOffsets,\n          startIndices,\n          squawks,\n        };\n\n        this.setState((prev) => ({\n          ...prev,\n          chunks: prev.chunks.concat([\n            {\n              rawItems: trajectoryBatch,\n              positions,\n              timestampOffsets,\n              startIndices,\n              squawks,\n            },\n          ]),\n        }));\n        onChunkLoaded(chunk, chunkIndex);\n\n        chunkIndex++;\n\n        statistics.flights += trajectoryBatch.length;\n        statistics.drawnDataPoints += sampledIndices;\n        statistics.totalDataPoints += totalIndices;\n        onProgress(statistics);\n      }\n    }\n\n    if (signal.aborted) {\n      return;\n    }\n\n    this.setState((prev) => ({\n      ...prev,\n      loading: false,\n    }));\n  };\n}\n","import { schemeTableau10 } from 'd3-scale-chromatic';\nimport { decomposeColor } from '@mui/system/colorManipulator';\nimport { ftToM, tuple } from '../utils';\nimport type {\n  ColorFilterState,\n  ICatchAllFilter,\n  TrajectoryMetadata,\n  TrajectoryPlot,\n  RGBAColor,\n} from './types';\nimport { v4 } from 'uuid';\nimport { FLAT_UI_COLORS, TRIP_OPACITY, MUTED_TRIP_OPACITY } from './palette';\n\nexport const BASE_PALETTE_STRING = schemeTableau10.slice();\n\nexport const BASE_PALETTE = BASE_PALETTE_STRING.map((colorString) => {\n  const c = decomposeColor(colorString);\n  return tuple(c.values[0], c.values[1], c.values[2]);\n});\n\nexport function getRandomPaletteColor(\n  opacity: number = TRIP_OPACITY,\n): RGBAColor {\n  const idx = Math.floor(Math.random() * BASE_PALETTE.length);\n  const c = BASE_PALETTE[idx];\n  return [...c, opacity];\n}\n\nexport function createColorPalette({\n  count,\n  offset = 0,\n  opacity = TRIP_OPACITY,\n}: {\n  count: number;\n  offset?: number;\n  opacity?: number;\n}): Array<RGBAColor> {\n  const palette: Array<RGBAColor> = [];\n\n  for (let i = 0; i < count; i++) {\n    const color: RGBAColor = [\n      ...BASE_PALETTE[(i + offset) % BASE_PALETTE.length],\n      opacity,\n    ];\n    palette.push(color);\n  }\n\n  return palette;\n}\n\nconst CATCH_ALL_NORMAL: ColorFilterState & { type: 'catchAll' } = {\n  id: v4(),\n  type: 'catchAll',\n  enabled: true,\n  displayName: 'All flights',\n  color: [...FLAT_UI_COLORS.amethyst, TRIP_OPACITY],\n};\n\nconst CATCH_ALL_MUTED: ColorFilterState & { type: 'catchAll' } = {\n  id: v4(),\n  type: 'catchAll',\n  enabled: true,\n  displayName: 'Others',\n  color: [0x66, 0x66, 0x66, MUTED_TRIP_OPACITY],\n};\n\nexport function createCatchAllFilter(\n  mode: 'normal' | 'muted',\n): ICatchAllFilter {\n  const id = v4();\n\n  if (mode === 'normal') {\n    return { ...CATCH_ALL_NORMAL, id };\n  }\n\n  return { ...CATCH_ALL_MUTED, id };\n}\n\nexport function createFilterMatcher(\n  filter: ColorFilterState,\n): (\n  item: TrajectoryMetadata,\n) => ((plot: TrajectoryPlot) => boolean | RGBAColor) | boolean {\n  switch (filter.type) {\n    case 'catchAll': {\n      return () => true;\n    }\n    case 'aircraftOperator': {\n      const prefixes = new Set(filter.aircraftOperators);\n      return (item) =>\n        !!item.aircraftOperator && prefixes.has(item.aircraftOperator);\n    }\n    case 'callsign': {\n      const prefix = filter.startsWith.toUpperCase().trim();\n\n      return (item) => {\n        if (!item.callsign.startsWith(prefix)) {\n          return false;\n        }\n\n        if (\n          filter.maxLength != null &&\n          item.callsign.length > filter.maxLength\n        ) {\n          return false;\n        }\n\n        if (\n          filter.minLength != null &&\n          item.callsign.length < filter.minLength\n        ) {\n          return false;\n        }\n\n        return true;\n      };\n    }\n    case 'altitudeGradient': {\n      const {\n        topColor,\n        bottomColor,\n        topFt,\n        bottomFt,\n        excludeAbove = false,\n        excludeBelow = false,\n      } = filter;\n\n      const topM = ftToM(topFt);\n      const bottomM = ftToM(bottomFt);\n\n      const sameColors =\n        topColor[0] === bottomColor[0] &&\n        topColor[1] === bottomColor[1] &&\n        topColor[2] === bottomColor[2] &&\n        topColor[3] === bottomColor[3];\n\n      return (item) => {\n        return (plot) => {\n          const altitude = plot.altitudeM;\n\n          if (excludeAbove && altitude > topM) {\n            return TRANSPARENT;\n          }\n\n          if (excludeBelow && altitude < bottomM) {\n            return TRANSPARENT;\n          }\n\n          if (sameColors) {\n            if (altitude <= topM && altitude >= bottomM) {\n              return topColor;\n            }\n\n            return TRANSPARENT;\n          }\n\n          const ratio = invlerp(bottomM ?? 0, topM, altitude);\n\n          const r = lerp(bottomColor[0], topColor[0], ratio);\n          const g = lerp(bottomColor[1], topColor[1], ratio);\n          const b = lerp(bottomColor[2], topColor[2], ratio);\n          const a = lerp(bottomColor[3], topColor[3], ratio);\n\n          return [r, g, b, a];\n        };\n      };\n    }\n    // case 'altitudeRange': {\n    //   const [bottom, top] = filter.rangeM;\n\n    //   return () => (plot) => {\n    //     const altitude = plot.altitudeM;\n\n    //     return (\n    //       altitude <= (top ?? Infinity) && altitude >= (bottom ?? -Infinity)\n    //     );\n    //   };\n    // }\n    case 'airport': {\n      const prefixes = filter.airports.map((p) => p.toUpperCase().trim());\n\n      return (item) => {\n        return prefixes.some((prefix) => {\n          if (\n            (filter.airportFilterMode === 'departures' ||\n              filter.airportFilterMode === 'all') &&\n            item.departure?.startsWith(prefix)\n          ) {\n            return true;\n          }\n\n          if (\n            (filter.airportFilterMode === 'arrivals' ||\n              filter.airportFilterMode === 'all') &&\n            item.destination?.startsWith(prefix)\n          ) {\n            return true;\n          }\n\n          return false;\n        });\n      };\n    }\n    default: {\n      return () => false;\n    }\n  }\n}\n\n// https://www.trysmudford.com/blog/linear-interpolation-functions/\nconst lerp = (x: number, y: number, a: number) => x * (1 - a) + y * a;\nconst invlerp = (x: number, y: number, a: number) => clamp((a - x) / (y - x));\nconst clamp = (a: number, min = 0, max = 1) => Math.min(max, Math.max(min, a));\n\nconst TRANSPARENT: RGBAColor = [0, 0, 0, 0];\n","type RGBColor = [number, number, number];\n\nexport const MUI_COLORS = {\n  orange: [0xf5, 0x7c, 0x20] as RGBColor,\n  cyan: [0x00, 0xbc, 0xd4] as RGBColor,\n  red: [0xf4, 0x43, 0x36] as RGBColor,\n  indigo: [0x5c, 0x6b, 0xc0] as RGBColor,\n  amber: [0xff, 0xc1, 0x07] as RGBColor,\n  purple: [0x9c, 0x27, 0xb0] as RGBColor,\n  green: [0x4c, 0xaf, 0x50] as RGBColor,\n  deepOrange: [0xff, 0x57, 0x22] as RGBColor,\n  pink: [0xe9, 0x1e, 0x63] as RGBColor,\n  yellow: [0xff, 0xeb, 0x3b] as RGBColor,\n  lightBlue: [0x03, 0xa9, 0xf4] as RGBColor,\n  deepPurple: [0x67, 0x3a, 0xb7] as RGBColor,\n  lightGreen: [0x8b, 0xc3, 0xa4] as RGBColor,\n  teal: [0x00, 0x96, 0x88] as RGBColor,\n  blue: [0x21, 0x96, 0xf3] as RGBColor,\n  lime: [0xcd, 0xdc, 0x39] as RGBColor,\n};\n\nexport const FLAT_UI_COLORS = {\n  greensea: [0x16, 0xa0, 0x85] as RGBColor,\n  sunflower: [0xf1, 0xc4, 0x0f] as RGBColor,\n  peterriver: [0x34, 0x98, 0xdb] as RGBColor,\n  alizarin: [0xe7, 0x4c, 0x3c] as RGBColor,\n  // emerland: [0x2e, 0xcc, 0x71] as RGBColor,\n  amethyst: [0x9b, 0x59, 0xb6] as RGBColor,\n  carrot: [0xe6, 0x7e, 0x22] as RGBColor,\n};\n\nexport const TRIP_OPACITY = 0xa0;\nexport const MUTED_TRIP_OPACITY = 0x8;\n","import type { TrajectoryPlot, ColorFilterState, RGBAColor } from '../colors';\nimport { createCatchAllFilter, createFilterMatcher } from '../colors/utils';\nimport { TrajectoryChunk } from './DatasetCache';\n\nconst CATCH_ALL_FILTER = createCatchAllFilter('normal');\nCATCH_ALL_FILTER.color = [0xff, 0, 0, 0xff];\nconst TRANSPARENT: RGBAColor = [0, 0, 0, 0];\n\nexport class ColorProcessor {\n  private colorMatchers: Array<{\n    filter: ColorFilterState;\n    matcher: ReturnType<typeof createFilterMatcher>;\n  }> = [\n    {\n      filter: CATCH_ALL_FILTER,\n      matcher: createFilterMatcher(CATCH_ALL_FILTER),\n    },\n  ];\n\n  public computeColorChunk = ({\n    chunkIndex,\n    chunk,\n  }: {\n    chunkIndex: number;\n    chunk: TrajectoryChunk;\n  }) => {\n    const start = performance.now();\n    console.log(\n      `[ColorProcessor.computeColorCunk] Computing colors for chunk #${chunkIndex}, length=${chunk.rawItems.length}`,\n    );\n    if (!chunk) {\n      // We might want to throw an error here ?\n      console.warn(\n        `[ColorProcessor.computeColorCunk] Chunk #${chunkIndex} could not be found ?`,\n      );\n      return;\n    }\n\n    const length = chunk.timestampOffsets.length;\n    const colors = new Uint8Array(length * 4);\n\n    const itemIndices = chunk.startIndices;\n\n    // const altitudeRange = [(377 * 100) / 3.2808, (383 * 100) / 3.2808];\n\n    for (let itemIndex = 0; itemIndex < chunk.rawItems.length; itemIndex++) {\n      const currentItem = chunk.rawItems[itemIndex];\n      const startIndex = itemIndices[itemIndex];\n      const endIndex = itemIndices[itemIndex + 1] ?? length;\n      const color = this.getColorForItem(currentItem);\n\n      for (let i = startIndex; i < endIndex; i++) {\n        if (typeof color === 'function') {\n          const longitude = chunk.positions[i * 3];\n          const latitude = chunk.positions[i * 3 + 1];\n          const altitudeM = chunk.positions[i * 3 + 2];\n\n          const c = color({ latitude, longitude, altitudeM });\n          colors[i * 4] = c[0];\n          colors[i * 4 + 1] = c[1];\n          colors[i * 4 + 2] = c[2];\n          colors[i * 4 + 3] = c[3];\n        } else {\n          colors[i * 4] = color[0];\n          colors[i * 4 + 1] = color[1];\n          colors[i * 4 + 2] = color[2];\n          colors[i * 4 + 3] = color[3];\n        }\n      }\n    }\n\n    const end = performance.now() - start;\n    console.log(\n      `[ColorProcessor.computeColorChunk] Chunk #${chunkIndex} took ${end}ms`,\n    );\n    return colors;\n  };\n\n  public setColorFilters = (filters: Array<ColorFilterState>) => {\n    this.colorMatchers = filters.map((filter) => ({\n      filter,\n      matcher: createFilterMatcher(filter),\n    }));\n  };\n\n  private getColorForItem(\n    item: TrajectoryChunk['rawItems'][number],\n  ): RGBAColor | ((plot: TrajectoryPlot) => RGBAColor) {\n    /**\n     * This should never happen as there should always be a catchall filter\n     * in the last position.\n     */\n    if (this.colorMatchers.length === 0) {\n      return CATCH_ALL_FILTER.color;\n    }\n\n    const plotMatchers: Array<{\n      filter: ColorFilterState;\n      plotMatcher: (plot: TrajectoryPlot) => RGBAColor | boolean;\n    }> = [];\n    let itemMatcherColor: RGBAColor | undefined;\n\n    /**\n     * Matcher return value can either be a boolean or a function.\n     *\n     * This function is a plot matcher, taking each trajectory plot and returning a color.\n     */\n    for (const { filter, matcher } of this.colorMatchers) {\n      if (!filter.enabled) {\n        continue;\n      }\n\n      const matcherOutput = matcher(item);\n\n      if (typeof matcherOutput === 'function') {\n        plotMatchers.push({ filter, plotMatcher: matcherOutput });\n      }\n\n      if (matcher(item) === true) {\n        if (plotMatchers.length === 0) {\n          return filter.color;\n        }\n\n        itemMatcherColor = filter.color;\n      }\n    }\n\n    if (plotMatchers.length > 0) {\n      return (plot: TrajectoryPlot) => {\n        for (const { filter, plotMatcher } of plotMatchers) {\n          const output = plotMatcher(plot);\n          /**\n           * No match for this plot, continue\n           */\n          if (output === false) {\n            continue;\n          }\n\n          if (output === true) {\n            return filter.color;\n          }\n\n          return output;\n        }\n\n        return itemMatcherColor ?? TRANSPARENT;\n      };\n    }\n    /**\n     * If nothing matches, make it transparent\n     */\n    return TRANSPARENT;\n  }\n}\n","/* eslint-disable no-restricted-globals */\nimport type { DatasetLoadOptions, DatasetMetadata } from '../Loader/hooks';\nimport type { TrajectoryItem } from '../scripts/parseTrajectory';\nimport { DatasetCache } from './DatasetCache';\nimport type { ColorFilterState } from '../colors';\nimport { ColorProcessor } from './ColorProcessor';\n\nexport {};\n\nexport type DatasetLoadProgress = {\n  flights: number;\n  drawnDataPoints: number;\n  totalDataPoints: number;\n  downloadedFlights: number;\n  countByAo: { [key: string]: number };\n};\n\nexport type MainToWorkerMessage =\n  | {\n      type: 'LOAD_START';\n      loadOptions: DatasetLoadOptions;\n      metadata: DatasetMetadata;\n    }\n  | { type: 'LOAD_ABORT' }\n  | { type: 'SET_COLOR_RULES'; rules: Array<ColorFilterState> };\n\nexport type WorkerToMainMessage =\n  | { type: 'LOAD_START' }\n  | {\n      type: 'LOAD_CHUNK';\n      idx: number;\n      chunk: {\n        rawItems: Array<\n          Omit<TrajectoryItem, 'timestampOffsets' | 'coordinates'>\n        >;\n        positions: Float32Array;\n        timestampOffsets: Float32Array;\n        startIndices: Uint32Array;\n        squawks: Array<number | null>;\n      };\n    }\n  | {\n      type: 'LOAD_PROGRESS';\n      statistics: DatasetLoadProgress;\n    }\n  | { type: 'LOAD_DONE' }\n  | { type: 'LOAD_ERROR'; errorMessage: string }\n  | { type: 'COLOR_START' }\n  | { type: 'COLOR_ERROR'; errorMessage: string }\n  | {\n      type: 'COLOR_CHUNK';\n      chunkIndices: Array<number>;\n      colors: Array<Uint8Array>;\n    }\n  | { type: 'COLOR_DONE' };\n\nself.onmessage = handleInboundMessage;\n\nconst datasetCache = new DatasetCache();\nconst colorProcessor = new ColorProcessor();\n\nlet abortController = new AbortController();\nlet colorAbortController = new AbortController();\n\nasync function handleInboundMessage(\n  message: MessageEvent<MainToWorkerMessage>,\n) {\n  console.log('[worker] Message received !', message);\n  const { data } = message;\n\n  switch (data.type) {\n    case 'LOAD_START': {\n      if (abortController) {\n        abortController.abort();\n        abortController = new AbortController();\n      }\n\n      /**\n       * Cancel running color computing\n       */\n      if (colorAbortController) {\n        colorAbortController.abort();\n        colorAbortController = new AbortController();\n      }\n\n      console.log(\n        '[worker] Starting dataset load',\n        data.metadata,\n        data.loadOptions,\n        self.location,\n      );\n\n      const { metadata, loadOptions } = data;\n\n      postMessage({ type: 'COLOR_START' });\n      postMessage({ type: 'LOAD_START' });\n\n      try {\n        await datasetCache.start({\n          metadata,\n          loadOptions,\n          abortController,\n          onChunkLoaded: (baseChunk, idx) => {\n            /**\n             * We're creating new typed arrays for the main thread since we need to keep a hold of them\n             * to compute colors\n             */\n            const chunk = {\n              ...baseChunk,\n              positions: baseChunk.positions.slice(0),\n              timestampOffsets: baseChunk.timestampOffsets.slice(0),\n            };\n\n            postMessage(\n              {\n                type: 'LOAD_CHUNK',\n                idx,\n                chunk,\n              },\n              [chunk.positions.buffer, chunk.timestampOffsets.buffer],\n            );\n\n            let colors = colorProcessor.computeColorChunk({\n              chunk: baseChunk,\n              chunkIndex: idx,\n            });\n\n            if (!colors) {\n              return;\n            }\n\n            colors = colors.slice();\n\n            postMessage(\n              {\n                type: 'COLOR_CHUNK',\n                chunkIndices: [idx],\n                colors: [colors],\n              },\n              [colors.buffer],\n            );\n          },\n          onProgress: (statistics) => {\n            postMessage({ type: 'LOAD_PROGRESS', statistics });\n          },\n        });\n      } catch (err: any) {\n        postMessage({ type: 'LOAD_ERROR', errorMessage: err.message });\n        postMessage({ type: 'COLOR_ERROR', errorMessage: err.message });\n      }\n\n      console.log('[worker] Loading done !');\n      postMessage({ type: 'LOAD_DONE' });\n      postMessage({ type: 'COLOR_DONE' });\n\n      return;\n    }\n    case 'LOAD_ABORT': {\n      if (abortController) {\n        abortController.abort();\n        abortController = new AbortController();\n      }\n\n      return;\n    }\n    case 'SET_COLOR_RULES': {\n      if (colorAbortController) {\n        console.log('[worker]: Aborting previous run');\n        colorAbortController.abort();\n        colorAbortController = new AbortController();\n      }\n\n      const signal = colorAbortController.signal;\n\n      console.log(`[worker]: Setting color filters`);\n      colorProcessor.setColorFilters(data.rules);\n\n      postMessage({ type: 'COLOR_START' });\n      let queue: Array<{ idx: number; colors: Uint8Array }> = [];\n\n      let start = performance.now();\n      const MAX_WAIT = 1500;\n      for (const [idx, chunk] of datasetCache.state.chunks.entries()) {\n        if (signal.aborted) {\n          console.log('[worker]: Run aborted while not finished !');\n          colorAbortController = new AbortController();\n          return;\n        }\n\n        let colors = colorProcessor.computeColorChunk({\n          chunkIndex: idx,\n          chunk,\n        });\n\n        if (!colors) {\n          return;\n        }\n\n        queue.push({ idx, colors: colors.slice() });\n        const elapsed = performance.now() - start;\n\n        if (elapsed > MAX_WAIT) {\n          console.log('[worker]: elapsed > MAX_WAIT, flushing queue');\n          postMessage(\n            {\n              type: 'COLOR_CHUNK',\n              chunkIndices: queue.map(({ idx }) => idx),\n              colors: queue.map(({ colors }) => colors),\n            },\n            queue.map(({ colors }) => colors.buffer),\n          );\n          queue = [];\n          start = performance.now();\n        }\n\n        await delay(0);\n      }\n\n      if (queue.length) {\n        postMessage(\n          {\n            type: 'COLOR_CHUNK',\n            chunkIndices: queue.map(({ idx }) => idx),\n            colors: queue.map(({ colors }) => colors),\n          },\n          queue.map(({ colors }) => colors.buffer),\n        );\n      }\n\n      postMessage({ type: 'COLOR_DONE' });\n      return;\n    }\n    default:\n      console.log(`[worker]: Unhandled message type ${(data as any).type}`);\n  }\n}\n\nfunction postMessage(\n  message: WorkerToMainMessage,\n  transferable?: Array<Transferable>,\n) {\n  if (transferable) {\n    self.postMessage(message, transferable);\n  } else {\n    self.postMessage(message);\n  }\n}\n\nfunction delay(d: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, d));\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [531], function() { return __webpack_require__(6653); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","__webpack_require__.amdO = {};","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"4c8f2c38\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"https://aboveourheads.github.io/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t653: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkdatavis_test\"] = self[\"webpackChunkdatavis_test\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(531).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["gen","reader","signal","matcher","decoder","TextDecoder","shouldAbort","addEventListener","buf","next","read","console","log","done","value","length","JSON","parse","chunk","decode","stream","parts","split","pop","i","fetchNDJSONBatch","url","batchSize","limit","onBatchDownloaded","abortController","urls","Array","isArray","totalBatches","totalItems","fetch","cache","res","body","getReader","Error","iterator","currentBatch","push","return","ftToM","ft","DatasetCache","metadata","loadOptions","state","chunks","loading","error","start","onChunkLoaded","onProgress","setState","prev","statistics","flights","downloadedFlights","drawnDataPoints","totalDataPoints","countByAo","asyncIterator","hardLimit","undefined","total","samplingRate","sampleRate","chunkIndex","trajectoryBatch","aborted","sampledIndices","totalIndices","expectedPositions","t","aircraftOperator","expectedIndices","Math","floor","timestampOffsets","positions","Float32Array","squawks","fill","startIndices","Uint32Array","numberOfItems","coordinates","offset","j","altitudeM","callsign","rawItems","concat","updateFn","nextState","this","schemeTableau10","map","colorString","c","decomposeColor","args","tuple","values","CATCH_ALL_NORMAL","id","v4","type","enabled","displayName","color","CATCH_ALL_MUTED","createFilterMatcher","filter","prefixes","Set","aircraftOperators","item","has","prefix","startsWith","toUpperCase","trim","maxLength","minLength","topColor","bottomColor","topFt","bottomFt","excludeAbove","excludeBelow","topM","bottomM","sameColors","plot","altitude","TRANSPARENT","ratio","invlerp","lerp","airports","p","some","airportFilterMode","departure","destination","x","y","a","clamp","min","max","CATCH_ALL_FILTER","mode","createCatchAllFilter","ColorProcessor","colorMatchers","computeColorChunk","performance","now","colors","Uint8Array","itemIndices","itemIndex","currentItem","startIndex","endIndex","getColorForItem","longitude","latitude","end","warn","setColorFilters","filters","itemMatcherColor","plotMatchers","matcherOutput","plotMatcher","output","self","onmessage","handleInboundMessage","datasetCache","colorProcessor","AbortController","colorAbortController","message","data","abort","location","postMessage","baseChunk","idx","slice","buffer","chunkIndices","errorMessage","rules","queue","MAX_WAIT","entries","delay","transferable","d","Promise","resolve","setTimeout","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","call","m","__webpack_exports__","O","amdO","deferred","result","chunkIds","fn","priority","notFulfilled","Infinity","fulfilled","Object","keys","every","key","splice","r","n","getter","__esModule","definition","o","defineProperty","enumerable","get","f","e","chunkId","all","reduce","promises","u","miniCssF","obj","prop","prototype","hasOwnProperty","Symbol","toStringTag","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}